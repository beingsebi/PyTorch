# [01. PyTorch Workflow Fundamentals](https://colab.research.google.com/github/mrdbourke/pytorch-deep-learning/blob/main/01_pytorch_workflow.ipynb)

* [learnpytorch.io link](https://www.learnpytorch.io/01_pytorch_workflow/)

---

The essence of machine learning and deep learning is to take some data from the past, build an algorithm (like a neural network) to discover patterns in it and use the discovered patterns to predict the future.

<img  src="https://raw.githubusercontent.com/mrdbourke/pytorch-deep-learning/main/images/01_a_pytorch_workflow.png"  width=900  alt="a pytorch workflow flowchat"/> 

Specifically, we're going to cover:

 
<table>
<thead>
<tr>
  <th><strong>Topic</strong></th>
  <th><strong>Contents</strong></th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>1. Getting data ready</strong></td>
  <td>Data can be almost anything but to get started we're going to create a simple straight line</td>
</tr>
<tr>
  <td><strong>2. Building a model</strong></td>
  <td>Here we'll create a model to learn patterns in the data, we'll also choose a <strong>loss function</strong>, <strong>optimizer</strong> and build a <strong>training loop</strong>.</td>
</tr>
<tr>
  <td><strong>3. Fitting the model to data (training)</strong></td>
  <td>We've got data and a model, now let's let the model (try to) find patterns in the (<strong>training</strong>) data.</td>
</tr>
<tr>
  <td><strong>4. Making predictions and evaluating a model (inference)</strong></td>
  <td>Our model's found patterns in the data, let's compare its findings to the actual (<strong>testing</strong>) data.</td>
</tr>
<tr>
  <td><strong>5. Saving and loading a model</strong></td>
  <td>You may want to use your model elsewhere, or come back to it later, here we'll cover that.</td>
</tr>
<tr>
  <td><strong>6. Putting it all together</strong></td>
  <td>Let's take all of the above and combine it.</td>
</tr>
</tbody>
</table>

---
Again, it's best to learn via examples. Let's build a basic model that learns the pattern of a straight line and matches it. The model learns by *studying* `(x,y)` pairs, and after that, for given `x` values, it return corresponding `y` values.

## 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMzczNjEwNDUwLDE2NjUzOTQzMTgsMTU2MT
IwNjc0MSwtOTUyMzM0MzIsLTE2ODExMTc0ODgsNzMwOTk4MTE2
XX0=
-->